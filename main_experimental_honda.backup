/*
 * OBD2 AI Diagnostic Kiosk - Clean Version
 * For new ESP32 board with 2.2" LCD (240x320)
 * 
 * Maintains ALL original functionality but with cleaner code structure:
 * - WiFi and web API integration  
 * - QR code generation and display
 * - Payment processing integration
 * - Full kiosk state management
 * - Professional UI adapted for smaller screen
 * 
 * Hardware: ESP32 with TJA1050 CAN transceiver
 * Display: 2.2" TFT LCD (240x320 pixels)
 */

#include <Arduino.h>
#include <driver/twai.h>
#include <TFT_eSPI.h>
#include <qrcode.h>
#include <vector>
#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <ELMduino.h>

// ========== NEW BOARD PINOUTS ==========
#define CAN_TX_PIN    GPIO_NUM_5    // CAN TX (safe for ESP32-S3)
#define CAN_RX_PIN    GPIO_NUM_4    // CAN RX (safe for ESP32-S3)
#define SCAN_BUTTON   2           // SW_TRIG pin

// Complete pin definitions for proper GPIO configuration
const byte VBAT_MEAS   =  1; // Battery Meter
const byte SW_SEL      =  2; // SCAN_BUTTON
const byte SW_A        =  3; // D-Pad Up?
const byte SW_B        =  4; // CAN_RX_PIN
const byte SW_C        =  5; // CAN_TX_PIN
const byte SW_D        =  6; // D-Pad
const byte UNLOCK      =  7; // Unlock
const byte I2S_BCLK    =  8; // Sound I2S Bit Clock
const byte I2S_LRC     =  9; // Sound I2S Left/Right Clock
// TFT pins defined in platformio.ini: TFT_CS=10, TFT_DC=13, TFT_RST=14, TFT_BL=15
const byte SPI_MOSI_PIN= 11; // SPI
const byte SPI_SCK_PIN = 12; // SPI
const byte TINY_RX     = 16; // ATtiny RX (IR Wake)
const byte TINY_TX     = 17; // ATtiny TX (IR Wake)
const byte I2S_DOUT    = 18; // Sound I2S Data Out (Speaker)
const byte USB_N       = 19; // USB
const byte USB_P       = 20; // USB
const byte RGB_OUT     = 21; // Neopixel RGB LED
const byte IR_OUT      = 38; // IR LED
const byte RUMBLE      = 39; // Rumble
const byte IR_IN       = 40; // IR Sensor
const byte SW_TRIG     = 41; // Trigger Button
const byte SW_DOCK     = 42; // Dock Sensor
const byte IR_LATCH    = 45; // IR Brightness Shift Register
const byte I2C_SDA     = 47; // I2C
const byte I2C_SCL     = 48; // I2C

// Unused pins that need to be configured
const byte UNUSED_35   = 35;
const byte UNUSED_36   = 36;
const byte UNUSED_37   = 37;
const byte UNUSED_46   = 46;

// ========== DISPLAY CONFIGURATION ==========
// 2.2" LCD: 240x320 pixels - adapted from original 320x480
TFT_eSPI tft = TFT_eSPI();
const int SCREEN_WIDTH  = 240;
const int SCREEN_HEIGHT = 320;

// ========== KIOSK STATES ==========
enum KioskState {
  READY_SCREEN,    
  DISPLAY_QR,      
  PAYMENT_LOADING, 
  WAITING_PAYMENT,
  READY_TO_SCAN,
  PREPARE_VEHICLE,
  SCANNING,
  DISPLAY_RESULTS,
  SCAN_COMPLETE,
  ERROR_STATE,
  VEHICLE_SETUP,   
  VEHICLE_DETECTING,
  TROUBLESHOOTING  
};

KioskState currentState = DISPLAY_QR; // Boot directly to QR code

// ========== GLOBAL VARIABLES ==========
String transactionId           = "";
unsigned long stateStartTime   = 0;
unsigned long sessionStartTime = 0;
unsigned long lastPaymentCheck = 0;
int vehicleDetectionAttempt    = 0;

// TEST MODE - Set to true to bypass QR/payment and go straight to scanning
bool TEST_MODE = true;  // Set to false for production kiosk mode

// Display state tracking (to prevent redundant redraws)
bool screenDrawFlags[10] = {false}; // One for each state
bool forceRedraw = false; // Global flag to force all displays to redraw

// Session configuration
const unsigned long SESSION_TIMEOUT_MS    = 5 * 60 * 1000; // 5 minutes
const unsigned long PAYMENT_POLL_INTERVAL = 3000; // 3 seconds

// Diagnostic scan timeouts - Extended for comprehensive scanning
const unsigned long TOTAL_SCAN_TIMEOUT_MS     = 90 * 1000; // 90 seconds max scan time
const unsigned long BAUD_DETECT_TIMEOUT_MS    = 3000;     // 3 seconds per baud rate
const unsigned long TRAFFIC_LISTEN_TIMEOUT_MS = 8000;  // 8 seconds listening
const unsigned long ECU_PROBE_TIMEOUT_MS      = 20000;      // 20 seconds probing ECUs
const unsigned long DTC_SCAN_TIMEOUT_MS       = 30000;       // 30 seconds for DTC scanning

// WiFi and API configuration
const char* WIFI_SSID     = "Pasha";
const char* WIFI_PASSWORD = "E38740i!";
// const char* WIFI_SSID     = "Ibrahim";
// const char* WIFI_PASSWORD = "Newdad123!";
const char* API_BASE_URL  = "https://obd2ai-server-1afd74c5766a.herokuapp.com";
const char* WEBAPP_URL    = "https://obd2ai-webapp-805f8e39122c.herokuapp.com";
const char* KIOSK_ID      = "DEMO_KIOSK";

// OBD2 data structures
struct FaultCode {
  String code;
  String system;
  bool isPending;
  uint16_t ecuId;
};

std::vector<FaultCode> detectedCodes;
std::vector<uint16_t>  activeECUs;
bool vehicleDetected = false; // Track if vehicle was detected during scan
int scanRetryCount = 0; // Track scan retry attempts
twai_message_t message;
ELM327 myELM327;

// Standard OBD2 ECU addresses
const uint16_t OBD2_ADDRESSES[] = {
  0x7E0, 0x7E1, 0x7E2, 0x7E3, 0x7E4, 0x7E5, 0x7E6, 0x7E7,
  0x7E8, 0x7E9, 0x7EA, 0x7EB, 0x7EC, 0x7ED, 0x7EE, 0x7EF
};
const int NUM_ECUS = sizeof(OBD2_ADDRESSES) / sizeof(OBD2_ADDRESSES[0]);

// ========== FUNCTION DECLARATIONS ==========
// Initialization
void initializeDisplay();
void initializeWiFi();
void initializeCAN();

// Kiosk Management
void updateKioskState();
void handleSessionTimeout();
String createNewSession();
bool checkPaymentStatus();
bool submitDiagnosticResults();

// Enhanced OBD2 Protocol Detection
typedef enum {
  OBD2_PROTOCOL_NONE = 0,
  OBD2_PROTOCOL_CAN_11BIT_500K,
  OBD2_PROTOCOL_CAN_11BIT_250K,
  OBD2_PROTOCOL_CAN_29BIT_500K,
  OBD2_PROTOCOL_CAN_29BIT_250K,
  OBD2_PROTOCOL_ISO9141,
  OBD2_PROTOCOL_KWP2000
} obd2_protocol_t;

struct OBD2ProtocolInfo {
  obd2_protocol_t protocol;
  uint32_t baudRate;
  bool extendedId;
  uint32_t broadcastId;
  String name;
};

obd2_protocol_t detectOBD2Protocol();
bool testProtocol(OBD2ProtocolInfo* protocolInfo);
bool sendOBD2Handshake(uint32_t address, bool extended);
void scanWithBroadcastAddress(uint32_t broadcastId, bool extended);
void scanHondaSpecificDTCs(bool extended);
bool isHondaVehicle();
bool checkCANBusHealth();
void recoverFromBusOff();

// Display Functions (adapted for 240x320)
void displayReadyScreen();
void displayQRCode();
void displayPaymentLoading();
void displayWaitingPayment();
void displayReadyToScan(bool fullRedraw = false);
void displayPrepareVehicle();
void displayScanning(bool fullRedraw = false);
void displayScanResults();
void displayScanComplete();
void displayError(String message);
void drawQRCode(String data, int x, int y, int scale);

// Real CAN Bus Scanning
void performDiagnosticScan();
uint32_t autoDetectCANBaudRate();
void listenForCANTraffic(uint32_t duration_ms);
void probeOBD2ECUs();
void probeOBD2ECUsWithTimeout(uint32_t timeout_ms);
void scanAllDTCs();
bool testECUCommunication(uint16_t ecuId);
void scanForDTCs(uint16_t ecuId);
void parseAndStoreDTC(uint8_t* data, int len, uint16_t ecuId);
bool reinitializeCAN(uint32_t baudRate);
void updateScanProgress(String message, int percentage);

// Utility Functions
void handleButtonPress();
void resetToReady();
void resetDisplayFlags();

// ========== SETUP ==========
void setup() {
  Serial.begin(115200);
  
  delay(1000);
  
  Serial.println("=== OBD2 AI KIOSK - CLEAN VERSION ===");
  Serial.println("Board: New ESP32 with 2.2\" LCD");
  Serial.println("Features: Full functionality, cleaner code");
  Serial.println("Pins: CAN_TX=38, CAN_RX=40, BTN=41");
  Serial.println("====================================");
  
  // Initialize all systems
  initializeDisplay();
  initializeWiFi();
  initializeCAN();
  
  // Setup button (keeping for potential manual override)
  pinMode(SCAN_BUTTON, INPUT_PULLUP);
  
  // Configure all unused pins to prevent floating and spurious LED activation
  Serial.println("üîß Configuring unused pins to prevent floating...");
  pinMode(UNUSED_35, INPUT_PULLDOWN);  // UNUSED pin 35
  pinMode(UNUSED_36, INPUT_PULLDOWN);  // UNUSED pin 36  
  pinMode(UNUSED_37, INPUT_PULLDOWN);  // UNUSED pin 37
  pinMode(UNUSED_46, INPUT_PULLDOWN);  // UNUSED pin 46
  
  // Configure used pins that need specific states
  pinMode(RGB_OUT, OUTPUT);     // Pin 21 - RGB LED control
  pinMode(IR_OUT, OUTPUT);      // Pin 38 - IR LED  
  pinMode(RUMBLE, OUTPUT);      // Pin 39 - Rumble motor
  digitalWrite(RGB_OUT, LOW);   // Turn off RGB LED initially
  digitalWrite(IR_OUT, LOW);    // Turn off IR LED initially  
  digitalWrite(RUMBLE, LOW);    // Turn off rumble initially
  
  // Configure other input pins properly
  pinMode(SW_A, INPUT_PULLUP);        // Pin 3 - D-Pad
  pinMode(SW_D, INPUT_PULLUP);        // Pin 6 - D-Pad
  pinMode(SW_TRIG, INPUT_PULLUP);     // Pin 41 - Trigger button
  pinMode(SW_DOCK, INPUT_PULLUP);     // Pin 42 - Dock sensor
  pinMode(IR_IN, INPUT);              // Pin 40 - IR sensor (no pullup needed)
  pinMode(VBAT_MEAS, INPUT);          // Pin 1 - Battery measurement
  
  Serial.println("‚úÖ All pins configured - no floating pins");
  
  // Check if TEST MODE is enabled
  if (TEST_MODE) {
    Serial.println("üß™ TEST MODE ENABLED - Bypassing QR/payment process");
    Serial.println("   Going directly to scanning mode for development/testing");
    transactionId = "TEST_MODE_" + String(millis());
    currentState = READY_TO_SCAN;
    sessionStartTime = millis();
    Serial.println("‚úì TEST mode initialized, ready to scan immediately");
  } else {
    // Normal kiosk mode - Create session immediately on boot with retry logic
    Serial.println("üöÄ Boot-to-scan mode: Creating session automatically...");
    
    // Try to create session with retries
    int retryCount = 0;
    while (retryCount < 3 && transactionId.length() == 0) {
      if (retryCount > 0) {
        Serial.printf("üîÑ Retry %d/3: Attempting to create session...\n", retryCount);
        delay(2000); // Wait 2 seconds between retries
      }
      
      transactionId = createNewSession();
      retryCount++;
    }
    
    if (transactionId.length() > 0) {
      currentState = DISPLAY_QR;
      sessionStartTime = millis();
      lastPaymentCheck = millis(); // Initialize payment polling
      Serial.println("‚úì Session created on boot: " + transactionId);
      Serial.println("‚úì QR code will be displayed immediately");
    } else {
      Serial.println("‚ùå Failed to create session after 3 attempts");
      Serial.println("‚ùå WiFi: " + String(WiFi.status() == WL_CONNECTED ? "Connected" : "Disconnected"));
      Serial.println("‚è∞ Will retry session creation in main loop...");
      currentState = READY_SCREEN; // Fallback, but will retry in loop
    }
  }
  
  stateStartTime = millis();
  Serial.println("‚úì Kiosk initialized in boot-to-scan mode");
}

// ========== MAIN LOOP ==========
void loop() {
  // Button still available for manual override/debugging
  handleButtonPress();
  updateKioskState();
  handleSessionTimeout();
  delay(50);
}

// ========== INITIALIZATION FUNCTIONS ==========
void initializeDisplay() {
  // Set up backlight pin (TFT_BL = 15)
  pinMode(15, OUTPUT);
  digitalWrite(15, HIGH); // Turn on backlight
  
  tft.init();
  tft.setRotation(1); // 90 degrees rotation for proper orientation (320x240)
  tft.fillScreen(TFT_BLACK);
  tft.setTextColor(TFT_WHITE, TFT_BLACK);
  
  // Test display with a simple message
  tft.setTextSize(2);
  tft.setCursor(10, 10);
  tft.println("KIOSK");
  tft.setCursor(10, 40);
  tft.println("STARTING...");
  delay(2000);
  tft.fillScreen(TFT_BLACK); // Clear test message
  
  Serial.println("‚úì Display initialized (240x320) with backlight");
}

void initializeWiFi() {
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  
  Serial.print("Connecting to WiFi");
  while (WiFi.status() != WL_CONNECTED && millis() < 10000) {
    delay(500);
    Serial.print(".");
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n‚úì WiFi connected: " + WiFi.localIP().toString());
  } else {
    Serial.println("\n‚ùå WiFi connection failed");
  }
}

void initializeCAN() {
  Serial.println("üèéÔ∏è HONDA-SAFE CAN INITIALIZATION");
  
  // Step 1: Keep transceiver in standby during ESP32 boot (Honda requirement)
  // TODO: Add transceiver standby control if hardware supports it
  Serial.println("   Step 1: Transceiver standby during boot");
  
  // Step 2: Initialize CAN in listen-only mode first (Honda requirement)
  Serial.println("   Step 2: Starting in listen-only mode to validate bus");
  twai_general_config_t g_config = TWAI_GENERAL_CONFIG_DEFAULT(CAN_TX_PIN, CAN_RX_PIN, TWAI_MODE_LISTEN_ONLY);
  twai_timing_config_t t_config  = TWAI_TIMING_CONFIG_500KBITS();
  twai_filter_config_t f_config  = TWAI_FILTER_CONFIG_ACCEPT_ALL();
  
  if (twai_driver_install(&g_config, &t_config, &f_config) == ESP_OK) {
    Serial.println("‚úì CAN driver installed in listen-only mode");
  } else {
    Serial.println("‚ùå Failed to install CAN driver");
    return;
  }
  
  if (twai_start() == ESP_OK) {
    Serial.println("‚úì CAN driver started in listen-only mode");
  } else {
    Serial.println("‚ùå Failed to start CAN driver");
    return;
  }
  
  // Step 3: Listen for bus activity to confirm Honda ECUs are present and stable
  Serial.println("   Step 3: Validating bus stability (Honda requirement)");
  unsigned long listenStart = millis();
  int frameCount = 0;
  
  while (millis() - listenStart < 2000) {  // 2 second listen window
    twai_message_t rxMessage;
    if (twai_receive(&rxMessage, pdMS_TO_TICKS(100)) == ESP_OK) {
      frameCount++;
      // Look for Honda ECM frames (usually 0x17C, 0x158, etc.)
      if (frameCount == 1) {
        Serial.printf("   üì° Bus active - first frame ID: 0x%03X\n", rxMessage.identifier);
      }
    }
  }
  
  if (frameCount > 0) {
    Serial.printf("‚úì Bus validated: %d frames in 2 seconds\n", frameCount);
  } else {
    Serial.println("‚ö†Ô∏è No bus activity detected - vehicle may be off");
  }
  
  // Step 4: Switch to normal mode for actual scanning (Honda will be ready)
  Serial.println("   Step 4: Switching to normal mode for Honda-safe scanning");
  twai_stop();
  twai_driver_uninstall();
  
  // Reinstall in normal mode for scanning
  g_config.mode = TWAI_MODE_NORMAL;
  if (twai_driver_install(&g_config, &t_config, &f_config) == ESP_OK &&
      twai_start() == ESP_OK) {
    Serial.println("‚úì Honda-safe CAN initialization complete");
  } else {
    Serial.println("‚ùå Failed to restart CAN in normal mode");
  }
}

// ========== KIOSK STATE MANAGEMENT ==========
void updateKioskState() {
  switch (currentState) {
    case READY_SCREEN:
      displayReadyScreen();
      
      // If we're in ready screen but should be in QR mode, try to create session
      if (transactionId.length() == 0 && WiFi.status() == WL_CONNECTED) {
        static unsigned long lastRetryAttempt = 0;
        if (millis() - lastRetryAttempt > 10000) { // Try every 10 seconds
          Serial.println("üîÑ Attempting to create session from ready screen...");
          transactionId = createNewSession();
          
          if (transactionId.length() > 0) {
            Serial.println("‚úÖ Session created successfully, switching to QR mode");
            currentState = DISPLAY_QR;
            sessionStartTime = millis();
            stateStartTime = millis();
            lastPaymentCheck = millis(); // Initialize payment polling
          }
          lastRetryAttempt = millis();
        }
      }
      break;
      
    case DISPLAY_QR:
      displayQRCode();
      // Check payment status while showing QR code - no automatic transition
      if (millis() - lastPaymentCheck > PAYMENT_POLL_INTERVAL) {
        lastPaymentCheck = millis();
        if (checkPaymentStatus()) {
          Serial.println("‚úÖ Payment confirmed! Preparing for vehicle scan...");
          currentState = PREPARE_VEHICLE;  // Give user time to prepare vehicle
          sessionStartTime = millis();
          stateStartTime = millis();
        }
      }
      break;
      
    case PAYMENT_LOADING:
      displayPaymentLoading();
      currentState = WAITING_PAYMENT;
      stateStartTime = millis();
      break;
      
    case WAITING_PAYMENT:
      displayWaitingPayment();
      
      // Check payment status periodically
      if (millis() - lastPaymentCheck > PAYMENT_POLL_INTERVAL) {
        lastPaymentCheck = millis();
        if (checkPaymentStatus()) {
          Serial.println("‚úÖ Payment confirmed! Preparing for vehicle scan...");
          currentState = PREPARE_VEHICLE;  // Give user time to prepare vehicle
          sessionStartTime = millis();
          stateStartTime = millis();
        }
      }
      break;
      
    case READY_TO_SCAN:
      displayReadyToScan();
      break;
      
    case PREPARE_VEHICLE:
      {
        displayPrepareVehicle();
        // Give user time to turn on ignition and prepare
        if (millis() - stateStartTime > 15000) { // 15 seconds to prepare
          currentState = SCANNING;
          stateStartTime = millis();
          Serial.println("üîç Starting diagnostic scan after preparation time...");
        }
      }
      break;
      
    case SCANNING:
      displayScanning();
      performDiagnosticScan();
      
      // Submit diagnostic results to database for AI analysis and email
      Serial.println("üì§ Submitting diagnostic results to server...");
      if (submitDiagnosticResults()) {
        Serial.println("‚úÖ Diagnostic results submitted successfully");
      } else {
        Serial.println("‚ùå Failed to submit diagnostic results");
      }
      
      currentState = DISPLAY_RESULTS;
      stateStartTime = millis();
      break;
      
    case DISPLAY_RESULTS:
      {
        displayScanResults();
        
        // Check if we should retry (no vehicle detected and retries available)
        if (!vehicleDetected && scanRetryCount < 2) { // Allow up to 2 retries
          if (millis() - stateStartTime > 5000) { // Show "no vehicle" for 5 seconds
            scanRetryCount++;
            Serial.printf("üîÑ Retry attempt %d/2 - returning to preparation...\n", scanRetryCount);
            currentState = PREPARE_VEHICLE;
            stateStartTime = millis();
          }
        } else {
          // Vehicle detected OR max retries reached - proceed to completion
          if (millis() - stateStartTime > 3000) { // Show results for 3 seconds
            currentState = SCAN_COMPLETE;
            stateStartTime = millis();
            Serial.println("‚û°Ô∏è Transitioning to scan completion screen");
            Serial.println("üîç DEBUG: vehicleDetected=" + String(vehicleDetected ? "true" : "false"));
            Serial.println("üîç DEBUG: detectedCodes.size()=" + String(detectedCodes.size()));
          }
        }
      }
      break;
      
    case SCAN_COMPLETE:
      {
        displayScanComplete();
        // Auto-return to ready after showing completion message
        if (millis() - stateStartTime > 15000) { // 15 seconds to read and disconnect
          Serial.println("üîÑ Auto-reset timeout reached, returning to ready state");
          resetToReady();
        }
      }
      break;
      
    case ERROR_STATE:
      // Auto-recover from error state
      if (millis() - stateStartTime > 5000) {
        resetToReady();
      }
      break;
  }
}

void handleSessionTimeout() {
  // Check for session timeout in paid states
  if ((currentState == WAITING_PAYMENT || currentState == READY_TO_SCAN || 
       currentState == SCANNING) && sessionStartTime > 0) {
    
    if (millis() - sessionStartTime > SESSION_TIMEOUT_MS) {
      displayError("Session timeout - returning to home");
      delay(2000);
      resetToReady();
    }
  }
}

// ========== BUTTON HANDLING ==========
void handleButtonPress() {
  static unsigned long lastPress = 0;
  static bool buttonPressed = false;
  
  bool currentButtonState = !digitalRead(SCAN_BUTTON);
  
  if (currentButtonState && !buttonPressed && (millis() - lastPress > 300)) {
    buttonPressed = true;
    lastPress = millis();
    
    Serial.println("üîò Button pressed in state: " + String(currentState));
    
    switch (currentState) {
      case READY_SCREEN:
        // Try session creation first, fallback to test mode if it fails
        Serial.println("üîó Attempting session creation...");
        transactionId = createNewSession();
        if (transactionId.length() > 0) {
          Serial.println("‚úÖ Session created successfully: " + transactionId);
          currentState = DISPLAY_QR;
          stateStartTime = millis();
          lastPaymentCheck = millis(); // Initialize payment polling
        } else {
          Serial.println("‚ùå Session creation failed, using offline test mode");
          transactionId = "OFFLINE_" + String(millis());
          currentState = READY_TO_SCAN;  // Skip QR/payment, go directly to scan
          stateStartTime = millis();
        }
        break;
        
      case READY_TO_SCAN:
        // Start diagnostic scan
        currentState = SCANNING;
        stateStartTime = millis();
        break;
        
      default:
        // Button press in other states - could be used for cancellation
        break;
    }
  } else if (!currentButtonState) {
    buttonPressed = false;
  }
}

// ========== SESSION MANAGEMENT ==========
String createNewSession() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("‚ùå No WiFi connection for session creation");
    return "";
  }
  
  Serial.println("üì° Connecting to API: " + String(API_BASE_URL));
  
  HTTPClient http;
  http.setTimeout(5000);  // 5 second timeout
  http.begin(String(API_BASE_URL) + "/kiosk/create-session");
  http.addHeader("Content-Type", "application/json");
  
  DynamicJsonDocument doc(200);
  doc["kioskId"]  = KIOSK_ID;
  doc["deviceId"] = WiFi.macAddress();
  
  String requestBody;
  serializeJson(doc, requestBody);
  
  Serial.println("üì§ Sending request: " + requestBody);
  
  int httpCode = http.POST(requestBody);
  String response = http.getString();
  http.end();
  
  Serial.println("üì• Response code: " + String(httpCode));
  Serial.println("üì• Response body: " + response);
  
  if (httpCode == 200) {
    DynamicJsonDocument responseDoc(500);
    deserializeJson(responseDoc, response);
    String sessionId = responseDoc["sessionId"];
    
    Serial.println("‚úì Session created: " + sessionId);
    return sessionId;
  } else {
    Serial.println("‚ùå Session creation failed: HTTP " + String(httpCode));
    Serial.println("    Response: " + response);
    return "";
  }
}

bool checkPaymentStatus() {
  if (transactionId.length() == 0) return false;
  
  HTTPClient http;
  http.begin(String(API_BASE_URL) + "/kiosk/check-payment/" + transactionId);
  
  int httpCode = http.GET();
  String response = http.getString();
  http.end();
  
  if (httpCode == 200) {
    DynamicJsonDocument doc(500);
    deserializeJson(doc, response);
    bool paid = doc["paid"];
    
    if (paid) {
      Serial.println("‚úì Payment confirmed!");
      return true;
    }
  }
  
  return false;
}

bool submitDiagnosticResults() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("‚ùå No WiFi connection for results submission");
    return false;
  }
  
  if (transactionId.length() == 0) {
    Serial.println("‚ùå No transaction ID for results submission");
    return false;
  }
  
  Serial.println("üì° Submitting diagnostic results to API...");
  
  HTTPClient http;
  http.setTimeout(10000);  // 10 second timeout for results submission
  String endpoint = String(API_BASE_URL) + "/api/obd2/kiosk/" + KIOSK_ID + "/session/" + transactionId + "/results";
  http.begin(endpoint);
  http.addHeader("Content-Type", "application/json");
  
  // Create JSON payload with diagnostic results
  DynamicJsonDocument doc(2048);  // Larger buffer for diagnostic data
  
  // Add fault codes array
  JsonArray faultCodesArray = doc.createNestedArray("faultCodes");
  for (const auto& code : detectedCodes) {
    JsonObject faultObj = faultCodesArray.createNestedObject();
    faultObj["code"] = code.code;
    faultObj["system"] = code.system;
  }
  
  // Add vehicle info (this will be merged with payment data on server)
  JsonObject vehicleInfo = doc.createNestedObject("vehicleInfo");
  vehicleInfo["ecuCount"] = activeECUs.size();
  vehicleInfo["vehicleDetected"] = vehicleDetected;
  vehicleInfo["scanTimestamp"] = millis();
  
  // Add basic AI analysis summary (server will do full AI processing)
  String basicAnalysis;
  if (detectedCodes.size() > 0) {
    basicAnalysis = "ESP32 scan detected " + String(detectedCodes.size()) + " fault code(s). ";
  } else if (vehicleDetected) {
    basicAnalysis = "ESP32 scan completed successfully. No fault codes detected. Vehicle systems appear healthy. ";
  } else {
    basicAnalysis = "ESP32 scan could not detect vehicle. Please ensure OBD2 cable is connected and ignition is on. ";
  }
  basicAnalysis += "Full AI analysis and professional report will be generated server-side.";
  doc["aiAnalysis"] = basicAnalysis;
  
  String requestBody;
  serializeJson(doc, requestBody);
  
  Serial.println("üì§ Sending diagnostic results:");
  Serial.println("   Fault codes: " + String(detectedCodes.size()));
  Serial.println("   Active ECUs: " + String(activeECUs.size()));
  Serial.println("   Vehicle detected: " + String(vehicleDetected ? "Yes" : "No"));
  
  int httpCode = http.POST(requestBody);
  String response = http.getString();
  http.end();
  
  Serial.println("üì• Results response code: " + String(httpCode));
  if (httpCode != 201 && httpCode != 200) {
    Serial.println("üì• Error response: " + response);
    return false;
  }
  
  Serial.println("‚úÖ Diagnostic results submitted - AI analysis and email will be processed");
  return true;
}

// ========== DISPLAY FUNCTIONS (Adapted for 240x320) ==========
void displayReadyScreen() {
  static bool displayed = false;
  
  // Redraw if forced or not displayed
  if (displayed && !forceRedraw) return;
  displayed = true;
  forceRedraw = false; // Clear the force redraw flag
  
  tft.fillScreen(TFT_BLACK);
  
  // Header (adapted for smaller screen)
  tft.fillRect(0, 0, SCREEN_WIDTH, 40, TFT_DARKGREEN);
  tft.setTextSize(2);
  tft.setTextColor(TFT_WHITE);
  tft.setCursor(20, 8);
  tft.println("OBD2 KIOSK");
  tft.setTextSize(1);
  tft.setCursor(30, 25);
  tft.println("Vehicle Diagnostic Scanner");
  
  // Main content
  tft.setTextSize(3);
  tft.setTextColor(TFT_DARKGREEN);
  tft.setCursor(70, 100);
  tft.println("READY");
  
  // Instructions
  tft.setTextSize(1);
  tft.setTextColor(TFT_WHITE);
  tft.setCursor(20, 160);
  tft.println("Press button to start");
  tft.setCursor(20, 175);
  tft.println("professional vehicle");
  tft.setCursor(20, 190);
  tft.println("diagnostic scan");
  
  // Status bar
  tft.fillRect(0, SCREEN_HEIGHT-30, SCREEN_WIDTH, 30, TFT_DARKGREY);
  tft.setTextColor(TFT_LIGHTGREY);
  tft.setCursor(10, SCREEN_HEIGHT-20);
  String wifiStatus = "WiFi: ";
  wifiStatus += (WiFi.status() == WL_CONNECTED ? "Connected" : "Disconnected");
  tft.println(wifiStatus);
  
  Serial.println("üì∫ Ready screen displayed");
}

void displayQRCode() {
  static bool displayed = false;
  static unsigned long lastPaymentCheckDisplay = 0;
  
  // Only redraw the static parts once
  if (!displayed) {
    displayed = true;
    
    tft.fillScreen(TFT_WHITE);
    
    // Header
    tft.fillRect(0, 0, SCREEN_WIDTH, 40, TFT_BLUE);
    tft.setTextSize(1);
    tft.setTextColor(TFT_WHITE);
    tft.setCursor(60, 15);
    tft.println("SCAN QR CODE");
    
    // QR Code (use short URL to trigger router redirect with token)
    String qrData = String(WEBAPP_URL) + "/" + transactionId;
    drawQRCode(qrData, 30, 70, 3); // Version 6 QR codes are larger, use smaller scale
    
    // Instructions 
    tft.setTextSize(1);
    tft.setTextColor(TFT_BLACK);
    tft.setCursor(20, 220);
    tft.println("1. Scan QR with phone");
    tft.setCursor(20, 235);
    tft.println("2. Complete payment");
    tft.setCursor(20, 250);
    tft.println("3. Return to kiosk");
    
    Serial.println("üì∫ QR code displayed: " + qrData);
  }
  
  // Update payment status indicator every 2 seconds
  if (millis() - lastPaymentCheckDisplay > 2000) {
    lastPaymentCheckDisplay = millis();
    
    // Clear status area and show waiting message
    tft.fillRect(0, 270, SCREEN_WIDTH, 50, TFT_WHITE);
    
    // Show payment status
    tft.setTextSize(1);
    tft.setTextColor(TFT_ORANGE);
    tft.setCursor(20, 275);
    tft.println("Waiting for payment...");
    
    // Show elapsed time
    unsigned long elapsed = (millis() - stateStartTime) / 1000;
    tft.setTextColor(TFT_DARKGREY);
    tft.setCursor(20, 290);
    tft.printf("Time: %02d:%02d", (int)(elapsed / 60), (int)(elapsed % 60));
    
    // Add animated dots
    static int dots = 0;
    tft.setCursor(20, 305);
    tft.setTextColor(TFT_BLUE);
    for (int i = 0; i < (dots % 4); i++) {
      tft.print(".");
    }
    dots++;
  }
}

void displayPaymentLoading() {
  tft.fillScreen(TFT_YELLOW);
  
  tft.setTextSize(2);
  tft.setTextColor(TFT_BLACK);
  tft.setCursor(40, 120);
  tft.println("PROCESSING");
  tft.setCursor(60, 150);
  tft.println("PAYMENT");
  
  // Loading animation
  static int dots = 0;
  tft.setCursor(80, 180);
  for (int i = 0; i < dots % 4; i++) {
    tft.print(".");
  }
  dots++;
  
  Serial.println("üì∫ Payment loading displayed");
}

void displayWaitingPayment() {
  static bool displayed = false;
  if (displayed) return;
  displayed = true;
  
  tft.fillScreen(TFT_ORANGE);
  
  tft.setTextSize(2);
  tft.setTextColor(TFT_WHITE);
  tft.setCursor(30, 100);
  tft.println("WAITING FOR");
  tft.setCursor(50, 130);
  tft.println("PAYMENT");
  
  tft.setTextSize(1);
  tft.setCursor(20, 180);
  tft.println("Complete payment on");
  tft.setCursor(20, 195);
  tft.println("your phone, then");
  tft.setCursor(20, 210);
  tft.println("return to kiosk");
  
  Serial.println("üì∫ Waiting for payment displayed");
}

void displayReadyToScan(bool fullRedraw) {
  static bool displayed = false;
  if (displayed && !fullRedraw) return;
  displayed = true;
  
  if (TEST_MODE) {
    // TEST MODE display
    tft.fillScreen(TFT_ORANGE);
    
    tft.setTextSize(2);
    tft.setTextColor(TFT_BLACK);
    tft.setCursor(40, 80);
    tft.println("TEST MODE");
    
    tft.setTextSize(1);
    tft.setCursor(20, 120);
    tft.println("Development/Testing Mode");
    tft.setCursor(20, 140);
    tft.println("Bypassing payment process");
    
    tft.setTextSize(1);
    tft.setCursor(20, 180);
    tft.println("Connect OBD2 cable to");
    tft.setCursor(20, 195);
    tft.println("your vehicle's port");
    tft.setCursor(20, 210);
    tft.println("Press button to scan");
    
    Serial.println("üì∫ TEST MODE ready to scan displayed");
  } else {
    // Normal kiosk mode display
    tft.fillScreen(TFT_GREEN);
    
    tft.setTextSize(2);
    tft.setTextColor(TFT_WHITE);
    tft.setCursor(40, 100);
    tft.println("PAYMENT");
    tft.setCursor(50, 130);
    tft.println("SUCCESS");
    
    tft.setTextSize(1);
    tft.setCursor(20, 180);
    tft.println("Connect OBD2 cable to");
    tft.setCursor(20, 195);
    tft.println("your vehicle's port");
    tft.setCursor(20, 210);
    tft.println("Press button to scan");
    
    Serial.println("üì∫ Ready to scan displayed");
  }
}

void displayPrepareVehicle() {
  static bool displayed = false;
  static unsigned long lastUpdate = 0;
  
  // Redraw if forced or not displayed
  if (!displayed || forceRedraw) {
    displayed = true;
    if (forceRedraw) forceRedraw = false; // Clear the force redraw flag
    
    tft.fillScreen(TFT_ORANGE);
    
    // Header
    tft.fillRect(0, 0, SCREEN_WIDTH, 40, TFT_DARKCYAN);
    tft.setTextSize(1);
    tft.setTextColor(TFT_WHITE);
    tft.setCursor(40, 15);
    tft.println("PREPARE VEHICLE");
    
    // Main instructions
    tft.setTextSize(2);
    tft.setTextColor(TFT_WHITE);
    tft.setCursor(20, 70);
    tft.println("Please:");
    
    tft.setTextSize(1);
    tft.setTextColor(TFT_BLACK);
    int y = 110;
    tft.setCursor(10, y);
    tft.println("1. Turn on vehicle ignition");
    y += 20;
    tft.setCursor(10, y);
    tft.println("2. Engine can be ON or OFF");
    y += 20;
    tft.setCursor(10, y);
    tft.println("3. Ensure OBD2 cable is");
    y += 15;
    tft.setCursor(15, y);
    tft.println("firmly connected");
    y += 25;
    
    tft.setTextColor(TFT_DARKGREEN);
    tft.setCursor(10, y);
    tft.println("Scan will start automatically");
    
    Serial.println("üì∫ Prepare vehicle screen displayed");
  }
  
  // Update countdown every second
  if (millis() - lastUpdate > 1000) {
    lastUpdate = millis();
    
    // Calculate remaining time
    unsigned long elapsed = millis() - stateStartTime;
    unsigned long remaining = (15000 > elapsed) ? (15000 - elapsed) / 1000 : 0;
    
    // Update countdown at bottom
    tft.fillRect(10, SCREEN_HEIGHT - 25, SCREEN_WIDTH - 20, 20, TFT_ORANGE);
    tft.setTextColor(TFT_WHITE);
    tft.setTextSize(1);
    tft.setCursor(10, SCREEN_HEIGHT - 20);
    tft.printf("Starting scan in %d seconds...", (int)remaining);
  }
}

void displayScanning(bool fullRedraw) {
  static bool displayed = false;
  if (displayed && !fullRedraw) return;
  displayed = true;
  
  tft.fillScreen(TFT_BLUE);
  
  tft.setTextSize(2);
  tft.setTextColor(TFT_WHITE);
  tft.setCursor(50, 100);
  tft.println("SCANNING");
  tft.setCursor(60, 130);
  tft.println("VEHICLE");
  
  tft.setTextSize(1);
  tft.setCursor(20, 180);
  tft.println("Please wait while we");
  tft.setCursor(20, 195);
  tft.println("scan all vehicle");
  tft.setCursor(20, 210);
  tft.println("systems...");
  
  Serial.println("üì∫ Scanning displayed");
}

void displayScanResults() {
  static bool displayed = false;
  static unsigned long lastUpdate = 0;
  
  if (!displayed) {
    displayed = true;
    
    tft.fillScreen(TFT_WHITE);
    
    // Header
    tft.fillRect(0, 0, SCREEN_WIDTH, 40, TFT_NAVY);
    tft.setTextSize(1);
    tft.setTextColor(TFT_WHITE);
    tft.setCursor(60, 15);
    tft.println("SCAN COMPLETE");
    
    // Results summary
    int y = 60;
    tft.setTextSize(1);
    tft.setTextColor(TFT_BLACK);
    
    tft.setCursor(10, y);
    tft.println("Active ECUs: " + String(activeECUs.size()) + "/" + String(NUM_ECUS));
    y += 20;
    
    tft.setCursor(10, y);
    tft.println("Fault Codes: " + String(detectedCodes.size()));
    y += 30;
    
    // Display fault codes if any
    if (detectedCodes.size() > 0) {
      tft.setTextColor(TFT_RED);
      tft.setCursor(10, y);
      tft.println("ISSUES FOUND:");
      y += 15;
      
      for (int i = 0; i < min(5, (int)detectedCodes.size()); i++) {
        tft.setCursor(10, y);
        tft.println(detectedCodes[i].code + " - " + detectedCodes[i].system);
        y += 12;
      }
      
      // Instructions for issues found
      tft.setTextColor(TFT_BLACK);
      tft.setCursor(10, SCREEN_HEIGHT - 30);
      tft.println("Detailed report sent via email");
      
    } else if (!vehicleDetected) {
      // No vehicle detected case
      tft.setTextColor(TFT_ORANGE);
      tft.setCursor(10, y);
      tft.println("NO VEHICLE DETECTED");
      tft.setCursor(10, y + 20);
      tft.println("Please ensure:");
      tft.setCursor(10, y + 35);
      tft.println("- OBD2 cable is connected");
      tft.setCursor(10, y + 50);
      tft.println("- Vehicle is turned ON");
      tft.setCursor(10, y + 65);
      tft.println("- Engine is running");
      
    } else {
      // Vehicle found but no codes - THIS IS YOUR CASE!
      tft.setTextColor(TFT_GREEN);
      tft.setCursor(10, y);
      tft.println("ALL SYSTEMS OK!");
      tft.setCursor(10, y + 15);
      tft.println("No issues detected");
      
      // Instructions for good results
      tft.setTextColor(TFT_BLACK);
      tft.setCursor(10, SCREEN_HEIGHT - 30);
      tft.println("Health report sent via email");
    }
    
    Serial.println("üì∫ Scan results displayed");
  }
  
  // Update countdown every second for "no vehicle" case
  if (!vehicleDetected && millis() - lastUpdate > 1000) {
    lastUpdate = millis();
    
    // Calculate remaining time
    unsigned long elapsed = millis() - stateStartTime;
    unsigned long remaining = (60000 > elapsed) ? (60000 - elapsed) / 1000 : 0;
    
    // Update countdown
    tft.fillRect(10, SCREEN_HEIGHT - 30, SCREEN_WIDTH - 20, 20, TFT_WHITE);
    tft.setTextColor(TFT_DARKGREY);
    tft.setCursor(10, SCREEN_HEIGHT - 25);
    tft.printf("Returning to menu in %d seconds", (int)remaining);
  }
}

void displayScanComplete() {
  static bool displayed = false;
  static unsigned long lastUpdate = 0;
  
  // Redraw if forced or not displayed
  if (!displayed || forceRedraw) {
    displayed = true;
    if (forceRedraw) forceRedraw = false; // Clear the force redraw flag
    
    tft.fillScreen(TFT_WHITE);
    
    // Header
    tft.fillRect(0, 0, SCREEN_WIDTH, 40, TFT_DARKGREEN);
    tft.setTextSize(1);
    tft.setTextColor(TFT_WHITE);
    tft.setCursor(40, 15);
    tft.println("SCAN COMPLETE!");
    
    int y = 50;
    tft.setTextSize(2);
    tft.setTextColor(TFT_DARKGREEN);
    tft.setCursor(70, y);
    tft.println("DONE!");
    
    y += 35;
    tft.setTextSize(1);
    tft.setTextColor(TFT_BLACK);
    
    // Different messages based on results
    if (detectedCodes.size() > 0) {
      // Issues found
      tft.setCursor(10, y);
      tft.println("Report with " + String(detectedCodes.size()) + " issue(s)");
      y += 15;
      tft.setCursor(10, y);
      tft.println("being sent to your email.");
      y += 30;
      
      tft.setTextColor(TFT_ORANGE);
      tft.setCursor(10, y);
      tft.println("Please review the detailed");
      y += 15;
      tft.setCursor(10, y);
      tft.println("analysis and recommendations.");
      
    } else if (vehicleDetected) {
      // Vehicle healthy
      tft.setCursor(10, y);
      tft.println("Vehicle health report");
      y += 15;
      tft.setCursor(10, y);
      tft.println("being sent to your email.");
      y += 30;
      
      tft.setTextColor(TFT_DARKGREEN);
      tft.setCursor(10, y);
      tft.println("Your vehicle is running");
      y += 15;
      tft.setCursor(10, y);
      tft.println("in excellent condition!");
      
    } else {
      // No vehicle detected
      tft.setCursor(10, y);
      tft.println("Please ensure OBD2 cable");
      y += 15;
      tft.setCursor(10, y);
      tft.println("is properly connected.");
    }
    
    // Disconnection instructions - ensure they're visible and don't conflict with countdown
    y += 15; // Add space after previous content
    tft.setTextColor(TFT_NAVY);
    tft.setTextSize(1);
    tft.setCursor(10, y);
    tft.println("Please disconnect OBD2 cable");
    y += 12;
    tft.setCursor(10, y);
    tft.println("from your vehicle.");
    y += 15;
    tft.setCursor(10, y);
    tft.println("Thank you for using OBD2Ai!");
    
    Serial.println("üì∫ Scan completion screen displayed");
  }
  
  // Update countdown every second
  if (millis() - lastUpdate > 1000) {
    lastUpdate = millis();
    
    // Calculate remaining time
    unsigned long elapsed = millis() - stateStartTime;
    unsigned long remaining = (15000 > elapsed) ? (15000 - elapsed) / 1000 : 0;
    
    // Update countdown at bottom - only clear the countdown area
    tft.fillRect(10, SCREEN_HEIGHT - 20, SCREEN_WIDTH - 20, 20, TFT_WHITE);
    tft.setTextColor(TFT_DARKGREY);
    tft.setTextSize(1);
    tft.setCursor(10, SCREEN_HEIGHT - 15);
    tft.printf("Next customer ready in %ds", (int)remaining);
  }
}

void displayError(String message) {
  tft.fillScreen(TFT_RED);
  
  tft.setTextSize(2);
  tft.setTextColor(TFT_WHITE);
  tft.setCursor(70, 100);
  tft.println("ERROR");
  
  tft.setTextSize(1);
  tft.setCursor(20, 140);
  tft.println(message);
  
  currentState = ERROR_STATE;
  stateStartTime = millis();
  
  Serial.println("‚ùå Error displayed: " + message);
}

// ========== QR CODE GENERATION ==========
void drawQRCode(String data, int x, int y, int scale) {
  QRCode qrcode;
  uint8_t qrcodeData[qrcode_getBufferSize(6)]; // Higher version for longer URLs
  qrcode_initText(&qrcode, qrcodeData, 6, 0, data.c_str());
  
  // Draw QR code
  for (uint8_t y0 = 0; y0 < qrcode.size; y0++) {
    for (uint8_t x0 = 0; x0 < qrcode.size; x0++) {
      uint16_t color = qrcode_getModule(&qrcode, x0, y0) ? TFT_BLACK : TFT_WHITE;
      tft.fillRect(x + x0 * scale, y + y0 * scale, scale, scale, color);
    }
  }
}

// ========== REAL CAN BUS SCANNING ==========
void performDiagnosticScan() {
  Serial.println("üîç PROFESSIONAL OBD2 DIAGNOSTIC SCAN");
  Serial.println("   Implementing commercial scan tool methodology...");
  unsigned long scanStartTime = millis();
  
  detectedCodes.clear();
  activeECUs.clear();
  vehicleDetected = false; // Reset vehicle detection flag
  
  // Update display with progress
  updateScanProgress("Detecting protocol...", 0);
  
  // Step 1: Professional Protocol Detection
  obd2_protocol_t detectedProtocol = detectOBD2Protocol();
  if (detectedProtocol == OBD2_PROTOCOL_NONE) {
    Serial.println("‚ùå No OBD2 protocol detected");
    updateScanProgress("No vehicle detected", 100);
    delay(3000); // Show message for 3 seconds
    return;
  }
  
  // Check overall timeout
  if (millis() - scanStartTime > TOTAL_SCAN_TIMEOUT_MS) {
    Serial.println("‚è∞ Scan timeout reached");
    updateScanProgress("Scan timeout", 100);
    delay(2000);
    return;
  }
  
  // Get protocol details for broadcast scanning
  OBD2ProtocolInfo detectedProtocolInfo;
  switch (detectedProtocol) {
    case OBD2_PROTOCOL_CAN_11BIT_500K:
      detectedProtocolInfo = {OBD2_PROTOCOL_CAN_11BIT_500K, 500000, false, 0x7DF, "CAN 11-bit 500kbps"};
      break;
    case OBD2_PROTOCOL_CAN_11BIT_250K:
      detectedProtocolInfo = {OBD2_PROTOCOL_CAN_11BIT_250K, 250000, false, 0x7DF, "CAN 11-bit 250kbps"};
      break;
    case OBD2_PROTOCOL_CAN_29BIT_500K:
      detectedProtocolInfo = {OBD2_PROTOCOL_CAN_29BIT_500K, 500000, true, 0x18DB33F1, "CAN 29-bit 500kbps"};
      break;
    case OBD2_PROTOCOL_CAN_29BIT_250K:
      detectedProtocolInfo = {OBD2_PROTOCOL_CAN_29BIT_250K, 250000, true, 0x18DB33F1, "CAN 29-bit 250kbps"};
      break;
    default:
      Serial.println("‚ùå Unsupported protocol detected");
      return;
  }
  
  Serial.printf("‚úÖ Protocol confirmed: %s\n", detectedProtocolInfo.name.c_str());
  vehicleDetected = true; // Vehicle was successfully detected!
  updateScanProgress("Vehicle found! Analyzing...", 25);
  
  // Check timeout
  if (millis() - scanStartTime > TOTAL_SCAN_TIMEOUT_MS) {
    Serial.println("‚è∞ Scan timeout reached during protocol detection");
    updateScanProgress("Scan timeout", 100);
    delay(2000);
    return;
  }
  
  // Step 2: Honda-Safe Professional Scanning Protocol
  Serial.println("üèéÔ∏è HONDA-SAFE PROFESSIONAL SCANNING");
  Serial.println("   Following Honda ECU communication best practices");
  
  // Honda Session Flow Implementation
  updateScanProgress("Honda-safe handshake...", 30);
  
  // Step 2a: Single VIN query for gentle handshake (Honda-safe)
  Serial.println("   üìã Step 1: Gentle VIN handshake");
  twai_message_t handshakeMsg;
  handshakeMsg.identifier = 0x7E0;  // Physical ECM address (Honda requirement)
  handshakeMsg.extd = 0;
  handshakeMsg.rtr = 0;
  handshakeMsg.data_length_code = 8;
  handshakeMsg.data[0] = 0x02;  // Length
  handshakeMsg.data[1] = 0x09;  // Mode 09 - Vehicle Info  
  handshakeMsg.data[2] = 0x02;  // PID 02 - VIN
  handshakeMsg.data[3] = 0x00;
  handshakeMsg.data[4] = 0x00;
  handshakeMsg.data[5] = 0x00;
  handshakeMsg.data[6] = 0x00;
  handshakeMsg.data[7] = 0x00;
  
  if (twai_transmit(&handshakeMsg, pdMS_TO_TICKS(200)) == ESP_OK) {
    Serial.println("   ‚úì VIN handshake sent - waiting for ECM response");
    delay(500);  // Let Honda ECM process and respond
    
    // Clear any responses
    twai_message_t response;
    while (twai_receive(&response, pdMS_TO_TICKS(50)) == ESP_OK) {
      // Just clear the buffer
    }
  }
  
  updateScanProgress("Honda DTC query...", 60);
  
  // Step 2b: Check CAN bus health before proceeding (Honda requirement)
  Serial.println("   üìä Checking CAN bus health before DTC query");
  if (!checkCANBusHealth()) {
    Serial.println("   üö® CAN bus unhealthy - attempting recovery");
    recoverFromBusOff();
    
    // Re-check after recovery
    if (!checkCANBusHealth()) {
      Serial.println("   ‚ùå CAN recovery failed - aborting Honda scan");
      updateScanProgress("CAN error - scan aborted", 100);
      return;
    }
  }
  
  // Step 2c: Single Mode 03 DTC query with Honda timing discipline
  Serial.println("   üîç Step 3: Single DTC query (3-5 queries/sec max)");
  delay(300);  // 300ms spacing = 3.3 queries/sec (Honda-safe)
  
  twai_message_t dtcMsg;
  dtcMsg.identifier = 0x7E0;  // Physical ECM address only
  dtcMsg.extd = 0;
  dtcMsg.rtr = 0;
  dtcMsg.data_length_code = 8;
  dtcMsg.data[0] = 0x01;  // Length
  dtcMsg.data[1] = 0x03;  // Mode 03 - Stored DTCs
  dtcMsg.data[2] = 0x00;
  dtcMsg.data[3] = 0x00;
  dtcMsg.data[4] = 0x00;
  dtcMsg.data[5] = 0x00;
  dtcMsg.data[6] = 0x00;
  dtcMsg.data[7] = 0x00;
  
  if (twai_transmit(&dtcMsg, pdMS_TO_TICKS(200)) == ESP_OK) {
    Serial.println("   üì° DTC query sent to Honda ECM");
    
    // Honda-safe response collection
    unsigned long start = millis();
    bool foundDTCs = false;
    
    while (millis() - start < 1500) {  // Shorter window - Honda responds quickly
      twai_message_t response;
      if (twai_receive(&response, pdMS_TO_TICKS(100)) == ESP_OK) {
        // Only process ECM DTC responses
        if (response.identifier == 0x7E8 && 
            response.data_length_code >= 3 && response.data[1] == 0x43) {
          Serial.printf("   ‚úÖ Honda ECM DTC response: ");
          for (int i = 0; i < response.data_length_code; i++) {
            Serial.printf("%02X ", response.data[i]);
          }
          Serial.println();
          parseAndStoreDTC(response.data, response.data_length_code, response.identifier);
          foundDTCs = true;
        }
      }
    }
    
    if (!foundDTCs) {
      Serial.println("   ‚úÖ No DTCs found - Honda ECM reports healthy");
    }
  }
  
  updateScanProgress("Honda-safe complete", 90);
  
  // Step 2c: Return to listen-only before finishing (Honda requirement)
  Serial.println("   üõ°Ô∏è Step 3: Returning to listen-only mode (Honda-safe shutdown)");
  delay(500);  // Let any remaining frames complete
  
  updateScanProgress("Scan complete!", 100);
  
  unsigned long scanDuration = millis() - scanStartTime;
  Serial.printf("‚úì Scan complete: %d active ECUs, %d fault codes (%.1fs)\n", 
                activeECUs.size(), detectedCodes.size(), scanDuration / 1000.0);
}

bool testECUCommunication(uint16_t ecuId) {
  twai_message_t msg;
  msg.identifier = ecuId;
  msg.data_length_code = 8;
  msg.data[0] = 0x02;  // Length
  msg.data[1] = 0x01;  // Mode 01
  msg.data[2] = 0x00;  // PID 00
  msg.data[3] = 0x00;
  msg.data[4] = 0x00;
  msg.data[5] = 0x00;
  msg.data[6] = 0x00;
  msg.data[7] = 0x00;
  
  if (twai_transmit(&msg, pdMS_TO_TICKS(100)) != ESP_OK) {
    return false;
  }
  
  twai_message_t response;
  if (twai_receive(&response, pdMS_TO_TICKS(500)) == ESP_OK) {
    return (response.identifier == (ecuId + 8));
  }
  
  return false;
}

void scanForDTCs(uint16_t ecuId) {
  twai_message_t msg;
  msg.identifier = ecuId;
  msg.data_length_code = 8;
  msg.data[0] = 0x01;  // Length
  msg.data[1] = 0x03;  // Mode 03 - Read DTCs
  msg.data[2] = 0x00;
  msg.data[3] = 0x00;
  msg.data[4] = 0x00;
  msg.data[5] = 0x00;
  msg.data[6] = 0x00;
  msg.data[7] = 0x00;
  
  if (twai_transmit(&msg, pdMS_TO_TICKS(100)) != ESP_OK) {
    return;
  }
  
  twai_message_t response;
  if (twai_receive(&response, pdMS_TO_TICKS(500)) == ESP_OK) {
    if (response.data_length_code > 2) {
      parseAndStoreDTC(response.data, response.data_length_code, ecuId);
    }
  }
}

void parseAndStoreDTC(uint8_t* data, int len, uint16_t ecuId) {
  for (int i = 2; i < len - 1; i += 2) {
    uint8_t byte1 = data[i];
    uint8_t byte2 = data[i + 1];
    
    if (byte1 == 0 && byte2 == 0) continue;
    
    // Determine DTC type
    char category = 'P';
    if ((byte1 & 0xC0) == 0x40) category = 'C';
    else if ((byte1 & 0xC0) == 0x80) category = 'B';
    else if ((byte1 & 0xC0) == 0xC0) category = 'U';
    
    int codeNumber = ((byte1 & 0x3F) << 8) | byte2;
    String dtcCode = String(category) + String(codeNumber, HEX);
    dtcCode.toUpperCase();
    
    // Pad with zeros if needed
    while (dtcCode.length() < 5) {
      dtcCode = dtcCode.substring(0, 1) + "0" + dtcCode.substring(1);
    }
    
    FaultCode fault;
    fault.code = dtcCode;
    fault.ecuId = ecuId;
    fault.isPending = false;
    
    // Add better system description based on DTC code
    if (dtcCode.startsWith("P0")) {
      fault.system = "Engine/Powertrain";
    } else if (dtcCode.startsWith("P1")) {
      fault.system = "Fuel and Air Metering";
    } else if (dtcCode.startsWith("P2")) {
      fault.system = "Fuel and Air Metering (Injector Circuit)";
    } else if (dtcCode.startsWith("P3")) {
      fault.system = "Ignition System or Misfire";
    } else if (dtcCode.startsWith("B")) {
      fault.system = "Body Control";
    } else if (dtcCode.startsWith("C")) {
      fault.system = "Chassis";
    } else if (dtcCode.startsWith("U")) {
      fault.system = "Network/Communication";
    } else {
      fault.system = "Unknown System";
    }
    
    // Add specific descriptions for common codes
    if (dtcCode == "P0354") {
      fault.system = "Ignition Coil D Primary/Secondary Circuit";
    } else if (dtcCode == "P0301") {
      fault.system = "Engine - Cylinder 1 Misfire Detected";
    } else if (dtcCode == "P0420") {
      fault.system = "Catalyst System Efficiency Below Threshold";
    }
    
    detectedCodes.push_back(fault);
    
    Serial.printf("  üö® DTC found: %s from ECU 0x%03X\n", dtcCode.c_str(), ecuId);
  }
}

// ========== ENHANCED OBD2 PROTOCOL DETECTION ==========
obd2_protocol_t detectOBD2Protocol() {
  Serial.println("üîç PROFESSIONAL OBD2 PROTOCOL DETECTION");
  Serial.println("   Using commercial scan tool methodology...");
  
  // Define supported OBD2 protocols in order of prevalence
  OBD2ProtocolInfo protocols[] = {
    {OBD2_PROTOCOL_CAN_11BIT_500K, 500000, false, 0x7DF, "CAN 11-bit 500kbps"},
    {OBD2_PROTOCOL_CAN_11BIT_250K, 250000, false, 0x7DF, "CAN 11-bit 250kbps"},
    {OBD2_PROTOCOL_CAN_29BIT_500K, 500000, true,  0x18DB33F1, "CAN 29-bit 500kbps"},
    {OBD2_PROTOCOL_CAN_29BIT_250K, 250000, true,  0x18DB33F1, "CAN 29-bit 250kbps"}
  };
  
  int numProtocols = sizeof(protocols) / sizeof(protocols[0]);
  
  for (int i = 0; i < numProtocols; i++) {
    Serial.printf("üì° Testing Protocol: %s\n", protocols[i].name.c_str());
    
    if (testProtocol(&protocols[i])) {
      Serial.printf("‚úÖ PROTOCOL DETECTED: %s\n", protocols[i].name.c_str());
      Serial.printf("   Broadcast ID: 0x%08X\n", protocols[i].broadcastId);
      Serial.printf("   Extended ID: %s\n", protocols[i].extendedId ? "Yes" : "No");
      return protocols[i].protocol;
    }
  }
  
  Serial.println("‚ùå No OBD2 protocol detected");
  return OBD2_PROTOCOL_NONE;
}

bool testProtocol(OBD2ProtocolInfo* protocolInfo) {
  // Initialize CAN with protocol specifications
  if (!reinitializeCAN(protocolInfo->baudRate)) {
    Serial.printf("   ‚ùå Failed to initialize CAN at %d bps\n", protocolInfo->baudRate);
    return false;
  }
  
  Serial.printf("   üîß CAN initialized: %d bps, Extended: %s\n", 
                protocolInfo->baudRate, protocolInfo->extendedId ? "Yes" : "No");
  
  // Step 1: Listen for existing traffic
  Serial.println("   üëÇ Listening for existing CAN traffic...");
  unsigned long startTime = millis();
  int frameCount = 0;
  
  while (millis() - startTime < 2000) { // 2 second listen
    twai_message_t message;
    if (twai_receive(&message, pdMS_TO_TICKS(50)) == ESP_OK) {
      frameCount++;
      
      // Check if frame matches expected ID format
      bool validFrame = false;
      if (!protocolInfo->extendedId && !message.extd) {
        // 11-bit CAN - look for OBD2 response IDs (0x7E8-0x7EF)
        validFrame = (message.identifier >= 0x7E8 && message.identifier <= 0x7EF);
      } else if (protocolInfo->extendedId && message.extd) {
        // 29-bit CAN - look for ISO-TP response format
        validFrame = ((message.identifier & 0xFFFF0000) == 0x18DA0000);
      }
      
      if (validFrame) {
        Serial.printf("   ‚úÖ Valid OBD2 frame detected: ID=0x%08X\n", message.identifier);
        return true;
      }
    }
  }
  
  Serial.printf("   üìä Heard %d frames, but none were OBD2 responses\n", frameCount);
  
  // Step 2: Send handshake to broadcast address
  Serial.printf("   ü§ù Sending OBD2 handshake to broadcast 0x%08X...\n", protocolInfo->broadcastId);
  
  if (sendOBD2Handshake(protocolInfo->broadcastId, protocolInfo->extendedId)) {
    Serial.println("   ‚úÖ OBD2 handshake successful!");
    return true;
  }
  
  Serial.println("   ‚ùå No response to OBD2 handshake");
  return false;
}

bool sendOBD2Handshake(uint32_t address, bool extended) {
  twai_message_t msg;
  msg.identifier = address;
  msg.extd = extended ? 1 : 0;
  msg.rtr = 0;
  msg.data_length_code = 8;
  
  // Mode 01 PID 00 - Request supported PIDs (universal handshake)
  msg.data[0] = 0x02;  // Length
  msg.data[1] = 0x01;  // Mode 01 (Show current data)
  msg.data[2] = 0x00;  // PID 00 (Supported PIDs 01-20)
  msg.data[3] = 0x00;  // Padding
  msg.data[4] = 0x00;
  msg.data[5] = 0x00;
  msg.data[6] = 0x00;
  msg.data[7] = 0x00;
  
  // Send handshake
  if (twai_transmit(&msg, pdMS_TO_TICKS(100)) != ESP_OK) {
    Serial.println("   ‚ùå Failed to send handshake");
    return false;
  }
  
  // Wait for any ECU to respond
  unsigned long startTime = millis();
  while (millis() - startTime < 1000) { // 1 second timeout
    twai_message_t response;
    if (twai_receive(&response, pdMS_TO_TICKS(50)) == ESP_OK) {
      
      // Check if this looks like an OBD2 response
      bool validResponse = false;
      
      if (!extended && !response.extd) {
        // 11-bit: Response should be 0x7E8-0x7EF
        validResponse = (response.identifier >= 0x7E8 && response.identifier <= 0x7EF);
      } else if (extended && response.extd) {
        // 29-bit: Response should follow ISO-TP format
        validResponse = ((response.identifier & 0xFFFF0000) == 0x18DA0000);
      }
      
      if (validResponse && response.data_length_code >= 3) {
        // Check if response is Mode 01 PID 00 response (0x41 0x00 ...)
        if (response.data[1] == 0x41 && response.data[2] == 0x00) {
          Serial.printf("   ‚úÖ Valid Mode 01 PID 00 response from 0x%08X\n", response.identifier);
          Serial.printf("   üìã Supported PIDs: %02X %02X %02X %02X\n", 
                        response.data[3], response.data[4], response.data[5], response.data[6]);
          return true;
        }
      }
    }
  }
  
  return false;
}

void scanWithBroadcastAddress(uint32_t broadcastId, bool extended) {
  Serial.printf("üîç CONSERVATIVE BROADCAST SCAN to 0x%08X\n", broadcastId);
  Serial.println("   Using Honda-compatible timing and prioritized queries...");
  
  // Prioritized queries - focus on DTC detection first (Honda-friendly approach)
  struct {
    uint8_t mode;
    uint8_t pid;
    const char* description;
    int delayMs;  // Honda needs longer delays between queries
  } standardQueries[] = {
    {0x01, 0x00, "Supported PIDs 01-20", 500},        // Handshake first
    {0x03, 0x00, "Stored emission DTCs", 1000},       // Priority #1 - stored DTCs  
    {0x07, 0x00, "Pending emission DTCs", 1000},      // Priority #2 - pending DTCs
    {0x01, 0x01, "Monitor status since DTCs cleared", 750},
    {0x01, 0x03, "Fuel system status", 500},
    {0x09, 0x00, "Vehicle information supported", 500},
    {0x09, 0x02, "Vehicle identification number", 500}
  };
  
  int numQueries = sizeof(standardQueries) / sizeof(standardQueries[0]);
  
  for (int i = 0; i < numQueries; i++) {
    Serial.printf("üì° Broadcasting Mode %02X PID %02X: %s\n", 
                  standardQueries[i].mode, standardQueries[i].pid, standardQueries[i].description);
    
    twai_message_t msg;
    msg.identifier = broadcastId;
    msg.extd = extended ? 1 : 0;
    msg.rtr = 0;
    msg.data_length_code = 8;
    
    // Format standard OBD2 request
    if (standardQueries[i].pid == 0x00 && standardQueries[i].mode != 0x01) {
      // Mode 03/07 - DTC requests don't use PID
      msg.data[0] = 0x01;  // Length
      msg.data[1] = standardQueries[i].mode;
      msg.data[2] = 0x00;
    } else {
      // Standard Mode/PID request
      msg.data[0] = 0x02;  // Length
      msg.data[1] = standardQueries[i].mode;
      msg.data[2] = standardQueries[i].pid;
    }
    
    // Pad remaining bytes
    for (int j = 3; j < 8; j++) {
      msg.data[j] = 0x00;
    }
    
    // Send broadcast query with Honda-compatible approach
    Serial.printf("   üì° Sending query (waiting %dms after)...\n", standardQueries[i].delayMs);
    if (twai_transmit(&msg, pdMS_TO_TICKS(200)) == ESP_OK) {
      // Collect responses with longer timeout for Honda
      unsigned long queryStart = millis();
      int responseCount = 0;
      
      // Honda ECUs may need more time to respond, especially for DTC queries
      int collectionTime = (standardQueries[i].mode == 0x03 || standardQueries[i].mode == 0x07) ? 3000 : 2000;
      while (millis() - queryStart < collectionTime) {
        twai_message_t response;
        if (twai_receive(&response, pdMS_TO_TICKS(50)) == ESP_OK) {
          
          // Validate response format
          bool validResponse = false;
          if (!extended && !response.extd) {
            // 11-bit responses from 0x7E8-0x7EF
            validResponse = (response.identifier >= 0x7E8 && response.identifier <= 0x7EF);
          } else if (extended && response.extd) {
            // 29-bit ISO-TP responses
            validResponse = ((response.identifier & 0xFFFF0000) == 0x18DA0000);
          }
          
          if (validResponse && response.data_length_code >= 2) {
            responseCount++;
            vehicleDetected = true; // Mark vehicle as detected
            
            // Track active ECU
            bool ecuKnown = false;
            for (uint16_t ecu : activeECUs) {
              if (ecu == response.identifier) {
                ecuKnown = true;
                break;
              }
            }
            if (!ecuKnown) {
              activeECUs.push_back(response.identifier);
            }
            
            Serial.printf("   ‚úÖ Response #%d from ECU 0x%08X: ", responseCount, response.identifier);
            for (int j = 0; j < response.data_length_code; j++) {
              Serial.printf("%02X ", response.data[j]);
            }
            Serial.println();
            
            // Parse DTC responses (Mode 03/07)
            if ((standardQueries[i].mode == 0x03 || standardQueries[i].mode == 0x07) && 
                response.data_length_code > 2) {
              parseAndStoreDTC(response.data, response.data_length_code, response.identifier);
            }
          }
        }
      }
      
      Serial.printf("   üìä Query complete: %d ECU responses collected\n", responseCount);
    } else {
      Serial.printf("   ‚ùå Failed to send Mode %02X PID %02X query\n", 
                    standardQueries[i].mode, standardQueries[i].pid);
    }
    
    // Honda-specific delay between queries to prevent dashboard interference
    delay(standardQueries[i].delayMs);
  }
  
  Serial.printf("üéØ BROADCAST SCAN COMPLETE: %d active ECUs, %d DTCs\n", 
                activeECUs.size(), detectedCodes.size());
}

void scanHondaSpecificDTCs(bool extended) {
  Serial.println("üîß HONDA-SPECIFIC DTC SCANNING");
  Serial.println("   Using conservative timing and targeted ECU queries...");
  
  // Initial delay to let CAN bus settle
  delay(1000);
  
  // Minimal ECU addresses to prevent CAN bus disruption
  uint16_t hondaECUs[] = {
    0x7E0   // Engine ECU (PCM) only - most likely to have DTCs
    // ‚ùå REMOVED other ECUs to prevent U0100/U0029/U0155 communication errors
  };
  
  int numHondaECUs = sizeof(hondaECUs) / sizeof(hondaECUs[0]);
  
  for (int i = 0; i < numHondaECUs; i++) {
    uint16_t ecuAddr = hondaECUs[i];
    Serial.printf("üîç Honda ECU 0x%03X: Mode 03 DTC query...\n", ecuAddr);
    
    // Mode 03 - Stored DTCs (Honda priority)
    twai_message_t msg;
    msg.identifier = ecuAddr;
    msg.extd = extended ? 1 : 0;
    msg.rtr = 0;
    msg.data_length_code = 8;
    msg.data[0] = 0x01;  // Length
    msg.data[1] = 0x03;  // Mode 03
    msg.data[2] = 0x00;
    msg.data[3] = 0x00;
    msg.data[4] = 0x00;
    msg.data[5] = 0x00;
    msg.data[6] = 0x00;
    msg.data[7] = 0x00;
    
    if (twai_transmit(&msg, pdMS_TO_TICKS(200)) == ESP_OK) {
      // Honda ECUs may take longer to respond to DTC requests
      unsigned long start = millis();
      bool foundResponse = false;
      
      while (millis() - start < 3000 && !foundResponse) { // 3 second timeout per ECU
        twai_message_t response;
        if (twai_receive(&response, pdMS_TO_TICKS(100)) == ESP_OK) {
          
          // Look for valid Honda response
          bool validResponse = false;
          if (!extended && !response.extd) {
            validResponse = (response.identifier >= 0x7E8 && response.identifier <= 0x7EF);
          } else if (extended && response.extd) {
            validResponse = ((response.identifier & 0xFFFF0000) == 0x18DA0000);
          }
          
          if (validResponse) {
            foundResponse = true;
            
            // Track active ECU
            bool ecuKnown = false;
            for (uint16_t ecu : activeECUs) {
              if (ecu == response.identifier) {
                ecuKnown = true;
                break;
              }
            }
            if (!ecuKnown) {
              activeECUs.push_back(response.identifier);
            }
            
            Serial.printf("   ‚úÖ Honda ECU 0x%03X responded from 0x%03X: ", ecuAddr, response.identifier);
            for (int j = 0; j < response.data_length_code; j++) {
              Serial.printf("%02X ", response.data[j]);
            }
            Serial.println();
            
            // Parse DTC response
            if (response.data_length_code > 2) {
              parseAndStoreDTC(response.data, response.data_length_code, response.identifier);
            }
          }
        }
      }
      
      if (!foundResponse) {
        Serial.printf("   ‚ö†Ô∏è No response from Honda ECU 0x%03X\n", ecuAddr);
      }
    }
    
    // Honda-specific: Longer delay between ECU queries to prevent interference
    delay(2000);  // 2000ms between ECU queries to prevent CAN bus disruption
  }
  
  Serial.printf("üîß HONDA SCAN COMPLETE: Found %d DTCs\n", detectedCodes.size());
  
  // Final delay to let CAN bus settle before returning to normal vehicle operation
  delay(2000);
}

bool isHondaVehicle() {
  // Quick Honda detection using VIN query (Mode 09, PID 02)
  twai_message_t msg;
  msg.identifier = 0x7DF;  // Broadcast address
  msg.extd = 0;
  msg.rtr = 0;
  msg.data_length_code = 8;
  msg.data[0] = 0x02;  // Length
  msg.data[1] = 0x09;  // Mode 09 - Vehicle Info
  msg.data[2] = 0x02;  // PID 02 - VIN
  msg.data[3] = 0x00;
  msg.data[4] = 0x00;
  msg.data[5] = 0x00;
  msg.data[6] = 0x00;
  msg.data[7] = 0x00;
  
  if (twai_transmit(&msg, pdMS_TO_TICKS(200)) == ESP_OK) {
    unsigned long start = millis();
    while (millis() - start < 2000) {  // 2 second timeout
      twai_message_t response;
      if (twai_receive(&response, pdMS_TO_TICKS(100)) == ESP_OK) {
        // Look for VIN response
        if (response.data_length_code >= 7 && response.data[0] >= 0x06 && 
            response.data[1] == 0x49 && response.data[2] == 0x02) {
          // Check VIN characters for Honda indicators
          for (int i = 3; i < response.data_length_code && i < 8; i++) {
            char vinChar = (char)response.data[i];
            // Honda VINs typically start with 1H, 2H, 3H, JH, 19X, etc.
            if ((i == 3 && (vinChar == '1' || vinChar == '2' || vinChar == '3' || vinChar == 'J')) ||
                (i == 4 && vinChar == 'H')) {
              Serial.println("üèéÔ∏è Honda vehicle detected from VIN");
              return true;
            }
          }
        }
      }
    }
  }
  
  // Fallback: Check if responding to Honda ECU addresses
  msg.identifier = 0x7E0;  // Honda PCM address
  msg.data[1] = 0x01;  // Mode 01
  msg.data[2] = 0x00;  // Supported PIDs
  
  if (twai_transmit(&msg, pdMS_TO_TICKS(200)) == ESP_OK) {
    unsigned long start = millis();
    while (millis() - start < 1000) {
      twai_message_t response;
      if (twai_receive(&response, pdMS_TO_TICKS(100)) == ESP_OK) {
        if ((response.identifier == 0x7E8 || response.identifier == 0x7E9) &&
            response.data_length_code >= 3 && response.data[1] == 0x41) {
          Serial.println("üèéÔ∏è Honda vehicle detected from ECU response");
          return true;
        }
      }
    }
  }
  
  return false;  // Not detected as Honda
}

bool checkCANBusHealth() {
  // Monitor ESP32 TWAI error counters for bus-off conditions
  twai_status_info_t status_info;
  if (twai_get_status_info(&status_info) == ESP_OK) {
    Serial.printf("üìä CAN Status: RX_ERR=%d, TX_ERR=%d, State=%d\n", 
                  status_info.rx_error_counter, 
                  status_info.tx_error_counter,
                  status_info.state);
    
    // Check for bus-off condition (Honda-sensitive)
    if (status_info.state == TWAI_STATE_BUS_OFF) {
      Serial.println("üö® BUS-OFF detected - Honda ECU communication disrupted");
      return false;
    }
    
    // Check for high error rates
    if (status_info.tx_error_counter > 100 || status_info.rx_error_counter > 100) {
      Serial.println("‚ö†Ô∏è High CAN error rate - Honda ECU may be stressed");
      return false;
    }
    
    return true;
  }
  
  Serial.println("‚ùå Cannot read CAN status");
  return false;
}

void recoverFromBusOff() {
  Serial.println("üîß HONDA BUS-OFF RECOVERY PROCEDURE");
  
  // Step 1: Stop TWAI driver
  Serial.println("   Step 1: Stopping TWAI driver");
  twai_stop();
  
  // Step 2: Wait for Honda ECUs to recover
  Serial.println("   Step 2: Waiting 50ms for Honda ECU recovery");
  delay(50);
  
  // Step 3: Restart in listen-only first
  Serial.println("   Step 3: Restarting in listen-only mode");
  twai_general_config_t g_config = TWAI_GENERAL_CONFIG_DEFAULT(CAN_TX_PIN, CAN_RX_PIN, TWAI_MODE_LISTEN_ONLY);
  twai_timing_config_t t_config = TWAI_TIMING_CONFIG_500KBITS();
  twai_filter_config_t f_config = TWAI_FILTER_CONFIG_ACCEPT_ALL();
  
  twai_driver_uninstall();
  if (twai_driver_install(&g_config, &t_config, &f_config) == ESP_OK &&
      twai_start() == ESP_OK) {
    Serial.println("‚úì Listen-only recovery successful");
    
    // Step 4: Wait for bus stability before switching back
    delay(200);
    
    // Step 5: Switch back to normal mode
    twai_stop();
    twai_driver_uninstall();
    g_config.mode = TWAI_MODE_NORMAL;
    if (twai_driver_install(&g_config, &t_config, &f_config) == ESP_OK &&
        twai_start() == ESP_OK) {
      Serial.println("‚úì Honda bus-off recovery complete");
    }
  } else {
    Serial.println("‚ùå Bus-off recovery failed");
  }
}

// ========== REAL CAN BUS FUNCTIONS ==========
uint32_t autoDetectCANBaudRate() {
  Serial.println("üîç Auto-detecting CAN baud rate...");
  
  // Common OBD2 baud rates to try
  uint32_t baudRates[] = {500000, 250000, 125000, 1000000};
  int numRates = sizeof(baudRates) / sizeof(baudRates[0]);
  
  for (int i = 0; i < numRates; i++) {
    uint32_t baudRate = baudRates[i];
    Serial.printf("üì° Trying %d bps...\n", baudRate);
    
    if (reinitializeCAN(baudRate)) {
      // Listen for any CAN activity for shorter time per baud rate
      unsigned long startTime = millis();
      int frameCount = 0;
      
      while (millis() - startTime < BAUD_DETECT_TIMEOUT_MS) {
        twai_message_t message;
        if (twai_receive(&message, pdMS_TO_TICKS(100)) == ESP_OK) {
          frameCount++;
          if (frameCount >= 3) { // Found activity
            Serial.printf("‚úÖ CAN activity detected at %d bps (%d frames)\n", baudRate, frameCount);
            return baudRate;
          }
        }
      }
      Serial.printf("   No activity at %d bps\n", baudRate);
    }
  }
  
  return 0; // No activity detected
}

bool reinitializeCAN(uint32_t baudRate) {
  // Stop current driver
  twai_stop();
  twai_driver_uninstall();
  
  // Configure for new baud rate
  twai_general_config_t g_config = TWAI_GENERAL_CONFIG_DEFAULT(CAN_TX_PIN, CAN_RX_PIN, TWAI_MODE_NORMAL);
  twai_filter_config_t f_config = TWAI_FILTER_CONFIG_ACCEPT_ALL(); // Accept all messages
  
  twai_timing_config_t t_config;
  if (baudRate == 1000000) {
    t_config = TWAI_TIMING_CONFIG_1MBITS();
  } else if (baudRate == 500000) {
    t_config = TWAI_TIMING_CONFIG_500KBITS();
  } else if (baudRate == 250000) {
    t_config = TWAI_TIMING_CONFIG_250KBITS();
  } else if (baudRate == 125000) {
    t_config = TWAI_TIMING_CONFIG_125KBITS();
  } else {
    return false;
  }
  
  if (twai_driver_install(&g_config, &t_config, &f_config) != ESP_OK) {
    return false;
  }
  
  if (twai_start() != ESP_OK) {
    return false;
  }
  
  return true;
}

void listenForCANTraffic(uint32_t duration_ms) {
  Serial.println("üëÇ Listening for raw CAN traffic...");
  
  unsigned long startTime = millis();
  int frameCount = 0;
  std::vector<uint32_t> uniqueIDs;
  
  while (millis() - startTime < duration_ms) {
    twai_message_t message;
    if (twai_receive(&message, pdMS_TO_TICKS(50)) == ESP_OK) {
      frameCount++;
      
      // Log raw frame data
      Serial.printf("üì¶ CAN Frame #%d: ID=0x%03X DLC=%d Data=", 
                    frameCount, message.identifier, message.data_length_code);
      
      for (int i = 0; i < message.data_length_code; i++) {
        Serial.printf("%02X ", message.data[i]);
      }
      Serial.printf(" (Extended=%s)\n", message.extd ? "yes" : "no");
      
      // Track unique IDs
      bool found = false;
      for (uint32_t id : uniqueIDs) {
        if (id == message.identifier) {
          found = true;
          break;
        }
      }
      if (!found) {
        uniqueIDs.push_back(message.identifier);
      }
      
      // Update display periodically
      if (frameCount % 10 == 0) {
        tft.fillRect(0, 200, SCREEN_WIDTH, 20, TFT_BLACK);
        tft.setTextColor(TFT_WHITE);
        tft.setCursor(10, 200);
        tft.printf("Frames: %d IDs: %d", frameCount, uniqueIDs.size());
      }
    }
  }
  
  Serial.printf("üìä Traffic summary: %d frames, %d unique IDs\n", frameCount, uniqueIDs.size());
  
  // Log unique IDs found
  Serial.print("üÜî Unique CAN IDs: ");
  for (int i = 0; i < uniqueIDs.size() && i < 20; i++) {
    Serial.printf("0x%03X ", uniqueIDs[i]);
  }
  Serial.println();
}

void probeOBD2ECUs() {
  Serial.println("üîç Actively probing for OBD2 ECUs...");
  
  // Enhanced ECU probing with multiple methods
  Serial.println("üì° Enhanced ECU probing with multiple detection methods...");
  
  for (int i = 0; i < NUM_ECUS; i++) {
    uint16_t ecuAddr = OBD2_ADDRESSES[i];
    
    Serial.printf("üì° Probing ECU 0x%03X (%d/%d) with multiple methods...\n", ecuAddr, i + 1, NUM_ECUS);
    
    bool ecuFound = false;
    
    // Method 1: Mode 01 PID 00 (Supported PIDs) - Most common
    if (!ecuFound) {
      Serial.printf("  Method 1: Mode 01 PID 00...\n");
      
      twai_message_t msg;
      msg.identifier = ecuAddr;
      msg.flags = TWAI_MSG_FLAG_NONE;
      msg.data_length_code = 8;
    msg.data[0] = 0x02;  // Length
    msg.data[1] = 0x01;  // Mode 01 (Show current data)
    msg.data[2] = 0x00;  // PID 00 (Supported PIDs 01-20)
    msg.data[3] = 0x00;
    msg.data[4] = 0x00;
    msg.data[5] = 0x00;
    msg.data[6] = 0x00;
    msg.data[7] = 0x00;
    
    if (twai_transmit(&msg, pdMS_TO_TICKS(100)) == ESP_OK) {
      // Wait for response
      twai_message_t response;
      unsigned long start = millis();
      while (millis() - start < 1000) { // 1 second timeout
        if (twai_receive(&response, pdMS_TO_TICKS(50)) == ESP_OK) {
          // Check if this is a response to our query
          if (response.identifier == (ecuAddr + 8) || 
              (response.identifier >= 0x7E8 && response.identifier <= 0x7EF)) {
            
            activeECUs.push_back(response.identifier);
            Serial.printf("  ‚úÖ Active ECU found: 0x%03X responded from 0x%03X\n", 
                         ecuAddr, response.identifier);
            
            // Log response data
            Serial.printf("     Response: ");
            for (int j = 0; j < response.data_length_code; j++) {
              Serial.printf("%02X ", response.data[j]);
            }
            Serial.println();
            break;
          }
        }
      }
    }
    }  // Close the if (!ecuFound) block
    
    delay(100); // Brief pause between requests
  }
  
  Serial.printf("üéØ Found %d active OBD2 ECUs\n", activeECUs.size());
}

void probeOBD2ECUsWithTimeout(uint32_t timeout_ms) {
  Serial.println("üîç Actively probing for OBD2 ECUs with timeout...");
  unsigned long startTime = millis();
  
  // Send standard OBD2 query to detect active ECUs
  for (int i = 0; i < NUM_ECUS; i++) {
    // Check timeout
    if (millis() - startTime > timeout_ms) {
      Serial.printf("‚è∞ ECU probing timeout after %d ECUs\n", i);
      break;
    }
    
    uint16_t ecuAddr = OBD2_ADDRESSES[i];
    
    Serial.printf("üì° Probing ECU 0x%03X (%d/%d)...\n", ecuAddr, i + 1, NUM_ECUS);
    
    // Update progress on display
    if (i % 4 == 0) {
      int progress = 50 + (i * 25 / NUM_ECUS); // 50-75% range
      updateScanProgress("Checking ECU " + String(i+1) + "/" + String(NUM_ECUS), progress);
    }
    
    // Send Mode 01 PID 00 (Supported PIDs) request
    twai_message_t msg;
    msg.identifier = ecuAddr;
    msg.flags = TWAI_MSG_FLAG_NONE;
    msg.data_length_code = 8;
    msg.data[0] = 0x02;  // Length
    msg.data[1] = 0x01;  // Mode 01 (Show current data)
    msg.data[2] = 0x00;  // PID 00 (Supported PIDs 01-20)
    msg.data[3] = 0x00;
    msg.data[4] = 0x00;
    msg.data[5] = 0x00;
    msg.data[6] = 0x00;
    msg.data[7] = 0x00;
    
    if (twai_transmit(&msg, pdMS_TO_TICKS(100)) == ESP_OK) {
      // Wait for response with shorter timeout per ECU
      twai_message_t response;
      unsigned long ecuStart = millis();
      while (millis() - ecuStart < 800) { // 800ms per ECU max
        if (twai_receive(&response, pdMS_TO_TICKS(50)) == ESP_OK) {
          // Check if this is a response to our query
          if (response.identifier == (ecuAddr + 8) || 
              (response.identifier >= 0x7E8 && response.identifier <= 0x7EF)) {
            
            activeECUs.push_back(response.identifier);
            Serial.printf("  ‚úÖ Active ECU found: 0x%03X responded from 0x%03X\n", 
                         ecuAddr, response.identifier);
            
            // Log response data
            Serial.printf("     Response: ");
            for (int j = 0; j < response.data_length_code; j++) {
              Serial.printf("%02X ", response.data[j]);
            }
            Serial.println();
            break;
          }
        }
      }
    }
    
    delay(50); // Brief pause between requests
  }
  
  Serial.printf("üéØ Found %d active OBD2 ECUs\n", activeECUs.size());
}

void updateScanProgress(String message, int percentage) {
  // Update the scanning display with progress
  tft.fillRect(0, 180, SCREEN_WIDTH, 40, TFT_BLUE);
  tft.setTextColor(TFT_WHITE);
  tft.setTextSize(1);
  
  // Progress message
  tft.setCursor(20, 185);
  tft.println(message);
  
  // Progress bar
  int barWidth = SCREEN_WIDTH - 40;
  int barHeight = 8;
  int barX = 20;
  int barY = 200;
  
  // Progress bar background
  tft.fillRect(barX, barY, barWidth, barHeight, TFT_DARKGREY);
  
  // Progress bar fill
  int fillWidth = (barWidth * percentage) / 100;
  tft.fillRect(barX, barY, fillWidth, barHeight, TFT_WHITE);
  
  // Percentage text
  tft.setCursor(barX + barWidth + 5, barY);
  tft.printf("%d%%", percentage);
}

void scanAllDTCs() {
  Serial.println("üö® COMPREHENSIVE DTC SCAN - Multiple passes for maximum detection");
  Serial.printf("   Active ECUs found during probe: %d\n", activeECUs.size());
  Serial.println("   Performing 2-pass scan of all 16 standard OBD2 addresses...");
  
  unsigned long scanStart = millis();
  int initialDTCCount = detectedCodes.size();
  
  // Perform 2 passes to catch intermittent codes
  for (int pass = 1; pass <= 2; pass++) {
    Serial.printf("\nüîÑ DTC Scan Pass %d/2:\n", pass);
    
    // Scan ALL standard OBD2 addresses for DTCs, not just activeECUs
    // This ensures we don't miss codes like P0354 from ECUs that didn't respond to probes
    for (int i = 0; i < NUM_ECUS; i++) {
    uint16_t requestAddr = OBD2_ADDRESSES[i];
    uint16_t responseAddr = requestAddr + 8; // Standard OBD2 response offset
    
    Serial.printf("üîç Scanning ECU 0x%03X ‚Üí 0x%03X for DTCs...\n", requestAddr, responseAddr);
    
    // Try both Mode 03 (stored DTCs) and Mode 07 (pending DTCs)
    uint8_t modes[] = {0x03, 0x07};
    const char* modeNames[] = {"stored", "pending"};
    
    for (int m = 0; m < 2; m++) {
      Serial.printf("    Trying Mode %02X (%s DTCs)...\n", modes[m], modeNames[m]);
      
      twai_message_t msg;
      msg.identifier = requestAddr;
      msg.flags = TWAI_MSG_FLAG_NONE;
      msg.data_length_code = 8;
      msg.data[0] = 0x01;  // Length
      msg.data[1] = modes[m];  // Mode 03 or 07
      msg.data[2] = 0x00;
      msg.data[3] = 0x00;
      msg.data[4] = 0x00;
      msg.data[5] = 0x00;
      msg.data[6] = 0x00;
      msg.data[7] = 0x00;
      
      if (twai_transmit(&msg, pdMS_TO_TICKS(100)) == ESP_OK) {
        // Wait for DTC response
        unsigned long start = millis();
        bool foundResponse = false;
        
        while (millis() - start < 2000 && !foundResponse) { // Longer timeout for DTC responses
          twai_message_t response;
          if (twai_receive(&response, pdMS_TO_TICKS(50)) == ESP_OK) {
            if (response.identifier == responseAddr) {
              Serial.printf("    üìã Mode %02X Response from 0x%03X: ", modes[m], responseAddr);
              for (int i = 0; i < response.data_length_code; i++) {
                Serial.printf("%02X ", response.data[i]);
              }
              Serial.println();
              
              // Check if this is a positive response (not just "no DTCs")
              if (response.data_length_code > 2 && !(response.data_length_code == 3 && response.data[2] == 0x00)) {
                parseAndStoreDTC(response.data, response.data_length_code, responseAddr);
              } else if (response.data_length_code == 3 && response.data[2] == 0x00) {
                Serial.printf("    ‚úÖ No %s DTCs in this ECU\n", modeNames[m]);
              }
              foundResponse = true;
            }
          }
        }
        
        if (!foundResponse) {
          Serial.printf("    ‚ö†Ô∏è No response to Mode %02X from ECU 0x%03X\n", modes[m], requestAddr);
        }
      } else {
        Serial.printf("    ‚ùå Failed to send Mode %02X request to ECU 0x%03X\n", modes[m], requestAddr);
      }
      
      delay(50); // Small delay between mode requests
    }
      
      delay(100);
      
      // Check for timeout
      if (millis() - scanStart > DTC_SCAN_TIMEOUT_MS) {
        Serial.println("‚è∞ DTC scan timeout reached, stopping...");
        break;
      }
    }
    
    // Brief pause between passes
    if (pass == 1) {
      delay(500);
      Serial.printf("‚úì Pass %d complete, found %d new DTCs\n", pass, detectedCodes.size() - initialDTCCount);
    }
  }
  
  // Final summary
  int totalDTCs = detectedCodes.size();
  int newDTCs = totalDTCs - initialDTCCount;
  unsigned long scanDuration = millis() - scanStart;
  
  Serial.printf("\nüèÅ COMPREHENSIVE DTC SCAN COMPLETE:\n");
  Serial.printf("   Duration: %.1f seconds\n", scanDuration / 1000.0);
  Serial.printf("   Total DTCs found: %d\n", totalDTCs);
  Serial.printf("   New DTCs this scan: %d\n", newDTCs);
  
  if (totalDTCs > 0) {
    Serial.println("   Detected fault codes:");
    for (const auto& code : detectedCodes) {
      Serial.printf("   üö® %s - %s\n", code.code.c_str(), code.system.c_str());
    }
  } else {
    Serial.println("   ‚úÖ No diagnostic trouble codes detected");
  }
}

// ========== UTILITY FUNCTIONS ==========
void resetDisplayFlags() {
  // Force all display functions to redraw by setting the global flag
  forceRedraw = true;
}

void resetToReady() {
  // Clear all session data
  transactionId = "";
  sessionStartTime = 0;
  detectedCodes.clear();
  activeECUs.clear();
  vehicleDetected = false; // Reset vehicle detection flag
  scanRetryCount = 0; // Reset retry counter for new session
  
  // Reset display flags
  for (int i = 0; i < 10; i++) {
    screenDrawFlags[i] = false;
  }
  
  // Force all display functions to redraw
  forceRedraw = true;
  
  // Create new session and return to QR code for next customer
  Serial.println("üîÑ Creating new session for next customer...");
  transactionId = createNewSession();
  
  if (transactionId.length() > 0) {
    currentState = DISPLAY_QR;
    lastPaymentCheck = millis(); // Initialize payment polling for new session
    Serial.println("‚úì New session created: " + transactionId);
  } else {
    Serial.println("‚ùå Failed to create new session, showing ready screen");
    currentState = READY_SCREEN;
  }
  
  stateStartTime = millis();
  Serial.println("üîÑ Reset complete - ready for next customer");
}